\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{listings}
\graphicspath{ {./graphs/} }
\graphicspath{ {./code/} }

\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{CStyle}{
    backgroundcolor=\color{backgroundColour},   
    commentstyle=\color{mGreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{mPurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C
}


\title{\textbf{Operativsystem ID1206} \\ 
\textbf{Gröna trådar}}

\author{Axel Karlsson}

\begin{document}

\maketitle
\textbf
{\\\\1. Inledning\\\\}
Denna rapport är skriven i syft av att redovisa mitt arbete med seminarieuppgift tre, green, i kursen ID1206 Operativsystem. Uppgiften var att implementera ett trådbibliotek, likt pthreads i c. Programmet kallas green då green threads är namnet för trådar i user space, likt det vi gör. I första delen av rapporten beskriver jag min implementation och sedan har jag gjort benchmarks för att jämföra min implementation och pthreads.
  

\maketitle
\textbf
{\\\\1.2 Vad är ett trådbibliotek?\\\\}
Ett trådbibliotek tillåter oss att göra parallell programmering, att köra flera funktioner samtidigt. Målet är alltså att skapa en api som låter oss köra flera funktioner parallellt. Grunden till programmet är biblioteket ucontext, som möjliggör skapanded och bytet mellan kontexter. Uppgiften var sedan att skriva en schedulerare som kan hantera dessa kontexter och i den implementera ett api likt pthreads.
De funktioner som har implementerats a apin är green\_create(), green\_yield() och green\_join. Dessa funktioner motsvara funktionerna med samma namn i pthread biblioteket. Sedan har även pthred\_mutex och pthread\_cond implementerats. 

\maketitle
\textbf
{\\\\2. Hantera kontexter\\\\}
I del 2 av uppgiften implementerades api funktionerna green\_create(), green\_yield samt green\_join(). Dessa funktioner motsvarar de med liknande namn i pthreadbiblioteket. De är byggda utifrån structen green\_t (likt pthread\_t) som representerar en tråd. Denna struct innehåller bland annat en kontext, en funktion och argument. Vi exekverar sedan dessa trådar genom att byta till deras kontext som kör funktionen och sparar argumenten i trådstructen. Dessa trådar skeduleras i och med en länkad lista \``readyq''. Trådar plockas ur denna lista och exekveras.

\maketitle
\textbf
{\\\\2.1 Den givna implementationen av dalloc \& dfree\\\\}
Den implementation av malloc som var given i uppgiftens instruktioner är byggd omkring två datastrukturer, en länkad lista kallad freelist och en struct kallad head. Vi kombinerar dessa och skapar block av minne, som vi sedan delar ut med api:n dalloc() och dfree(). Dessa block lagras i ett datasegment som vi har reserverat i minnet med mmap(). 


\maketitle
\textbf
{\\\\2.2 Möjliga förbättringar\\\\}
I uppgiften var det även givet ett antal förslag på förbättringar på dalloc var av vi skulle implementera åtminstonne en. Jag har valt att implementera möjligheten att skapa fler arenor, vilket möjliggör en större heap samt fler möjligheter för multitrådad programmering.  Min implementation bygger på datastrukturen arena, som har samma funktionalitet som arenan i den givan implementationen. Dessa structs lagras i en länkad lista som kan utökas vid behov. Structen arena innehåller 3 pekare; arena, flist och next. Arena och flist fungerar som de globala head structsen med samma namn i den tidigare implementationen. Structen head har nu även en pekare home, som visar vilken arena det blocket ska lagras i när det frigörs.
\begin{lstlisting}[style=CStyle]

\end{lstlisting}
 

\maketitle
\textbf
{\\\\3 Benchmark\\\\}
Min implementation av malloc har benchmarkats med hjälp av ett program benchmark.c. Detta program har4 parametrar: minsize, maxsize, rounds och maxblocks. Programmet innehåller en loop som körs tills vi har kallat dalloc() rounds antal gånger. I varje iteration av loopen kommer antingen dalloc() kallas och efterfråga ett slumpmässigt antal byte mellan min-och maxsize, eller så kallas dfree() på en slumpmässig tidigare allokering. Maxblocks avser det högsta antalet allokeringar som kan existera samtidigt. \\\\
Detta benchmark har körts med alla tre versioner av malloc jag har implementerat (utan merge, med merge och med flera arenor) med följande parameterar:
\begin{itemize}
  \item minsize = 8 bytes
  \item maxsize = 180 bytes
  \item rounds = 5000 rounds
  \item maxblocks = 1000 blocks
\end{itemize}

\maketitle
\textbf
    {\\\\3.1 Resultat\\\\}
    I figur 1 ser vi att versionen av malloc som kan skapa nya arenor har avsevärt störra block än de andra två versionerna. Observera även de upprepade topparna då nya arenor skapas. 
        I figur 2 ser vi att versionen utan merge() får fler fria block ju fler anrop vi gör, samtidigt som de andra versionerna verkar öka långsammare eller avtar. Vi kan även här observera toppar i den lila kurvan då nya arenor skapas

    
\maketitle
\textbf
    {\\\\3.2 Slutsats\\\\}
    Det kan vara svårt att tyda figur 1, men jag behövde begränsa den längs y-axeln då den kommer upp i 64000 när vi har gjort 0 operationer (medellängden på blocken är väldigt stor i början). Det går enkelt att se att den versionen av malloc med förmågan att skapa flera arenor överlag har större fria block än de andra två. Jag vet inte riktigt hur jag ska tolka detta resultat, men jag misstänker att vi tillslut skulle få en medellängd närmre de andra om vi körde benchmarket tillräckligt länge då den i teorin borde vara samma som versionen med merge. \\\\

I figur två ser vi att versionen utan merge har avsevärt många fler fria block än de andra två. Min första instinkt sade mig att detta kan tolkas som att den har fler små block medans de andra två har få stora, men med tanke på resultaten i figur 1 vet jag inte om det är en korrekt tolkning.

\maketitle
\textbf
    {\\\\Reflektion\\\\}
    Resultaten jag fick var oväntade, särskilt att den genomsnittliga blockstorleken (figur 1) var så pass lika för alla tre implementationer. Jag misstänker att detta beror på min testmetod, då versionen av malloc med merge och utan flera arenar i princip är given i uppgiftens instruktioner, och därför förutsätter jag att den är någolunda optimerad. Förutom en mer rafinerad testmetod finns det flera förslag till förbättringar som jag inte har försökt mig på, som möjligtvis skulle kunna ge oss en ännu bättre dalloc. 

\end{document}
