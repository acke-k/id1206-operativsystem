#include <stdlib.h>
#include <ucontext.h>
#include <assert.h>
#include "green.h"

#define FALSE 0
#define TRUE 1

#define STACK_SIZE 4096

/* Dessa variabler definierar den context som körs */

// Skapa ny context (vad är det exakt?)
static ucontext_t main_cntx = {0};

// Initiera en ny green_t struktur, som pekar på den tidigare contexten och resten nullpekare
static green_t main_green = {&main_cntx, NULL, NULL, NULL, NULL, NULL, FALSE};

// Sätt running till den nya contexten
static green_t* running = &main_green;

/* green_create */
/*
Tar in en green_t struct, en funktion den ska utföra och args för den funktionen. Kopplar ihop green_t med dessa, fäster även en ny context till den och slutligen lägger den i "ready queue".
*/

/* Kön */
/*
  Jag har valt att använda en enkellänkad lista, med header elementet
  ready_head (det element som ska köras först är längst upp i listan).
*/
green_t ready_head = NULL;

// Lägg till ett element i ready-kön
void enqueue_ready(green_t* element) {
    if(ready_head == NULL) {
    ready_head = element;
    return;
  } else {
    green_t index = ready_head;
    while(index->next != NULL) {
      index = index->next;
    }
    index->next = element;
    return;
  }
}
// Ta ut ett element ur ready-kön
green_t* dequeue_ready() {
  if(ready_head == NULL) {
    printf("Attempt to dequeue when queue empty\n");
    return NULL;
  } else {
    green_t* retval = ready_head;
    ready_head = ready_head->next;
    retval_next = NULL;
    return retval;
  }
}
  

int green_create(green_t* new, void* (*fun)(void*), void* arg) {
  ucontext_t* cntx = (ucontext_t*)malloc(sizeof(ucontext_t));
  getcontext(cntx);

  void* stack = malloc(STACK_SIZE);

  cntx->uc_stack.ss_sp = stack;
  cntx->uc_stack.ss_size = STACK_SIZE;
  makecontext(cntx, green_thread, 0);

  new->context = cntx;
  new->fun = fun;
  new->arg = arg;
  new->next = NULL;
  new.>join = NULL;
  new->retval = NULL;
  new->zombie = FALSE;

  // add new to the ready queue..
  enqueue_ready(new);

  return 0;
}

/* green_thread */

void green_thread() {
  // Hittar den kontext som är "running"
  green_t* this = running;

  // Kör funktionen och spara resultatet
  void* result = (*this->fun)(this->arg);

  // Check if a thread is waiting for termination
  // if so place it in the ready queue, it is now a zombie process
  // Tolkning: Placera kontexten som har körts i kön som zombie.
  //           Vi terminerar den senare?
  
  // Place waiting (joining) thread in ready queue
  enqueue_ready(this);

  // save result of exec
  this->retval = result;
  
  // Set it to zombie (?)
  this->zombie = TRUE;

  // Find the next thread to run
  green_t* next = dequeue_ready();

  running = next;
  setcontext(next->context);
}


  

/* Denna funktion initierar vår första context vid startup (automatiskt) */

static void init() __attribute__((constructor));

void init() {
  getcontext(&main_cntx);
}
