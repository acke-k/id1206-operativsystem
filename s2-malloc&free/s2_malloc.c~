/* Maybe change the size of these variables in the future to reduce overhead or
   increase performance */
struct head {
  uint16_t bfree; // Is the block before free?
  uint16_t bsize; // The size of the block before
  uint16_t free;  // Is this block free?
  uint16_t size;  // The size of this block
  struct head *prev;  // The previous block in the list
  struct head *next;  // The next block in the list
};

#define TRUE 1
#define FALSE 0

#define HEAD (sizeof(struct head)) // For now, 24 bytes
#define MIN(size) (((size) > (8))?(size):(8)) // Smallest size of a block is 8 bytes?
#define LIMIT(size) (MIN(0) + HEAD + size)  // We need to fit 8 bytes & header
#define MAGIC(memory) ((struct head*)memory - 1)  // Retrive the head of a block
#define HIDE(block) (void*)((struct head*)block + 1) // Hide the head of a block

#define ALIGN 8 // Since we are using a 64 bit processor
#define ARENA (64*1024)  // The block we start out with, i.e. the size of the heap

/* BLOCK LOGIC */

// Takes in a pointer to a block and returns a pointer to the next/previous block
struct head *after(struct head *block) {
  return (struct head*)((int)(block + (block->size / 8)) + HEAD);
}
struct head *before(struct head *block) {
  return (struct head*)((int)(block - (block->size / 8)) - HEAD);
}

struct head *split(struct head *block, int size) {
  int rsize = block->size - HEAD - size;  // calculate how much space will remain in the given block
  block->size = rsize;

  struct head *splt = block + HEAD + (block->size) / 8;  // Find where the new block will begin
  splt->bsize = block->size;
  splt->bfree = block->free;
  splt->size = size;
  splt->free = TRUE;  // Should this be initialized as true or false after splitting?

  struct head *aft = block->next;
  aft->bsize = size;

  // NOTE: why aren't we typing block->next = splt ?
}

struct head *arena = NULL;
struct head *new() {
  if(arena != NULL) {
    printf("one arena already allocated\n");
    return NULL;
  }
  struct head *new = mmap(NULL, ARENA, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);

  if(new == MAP_FAILED) {
    printf("mmap failed: error %d\n", errno);
    return NULL;
  }

  /* Setting up the heap */
  
  uint size = ARENA - 2*HEAD; 
  // Make it so that we can not merge out of the arena in the front
  new->bfree = FALSE;
  new->bsize = 0;
  new->free = TRUE;
  new->size = size;

  struct head *sentinel = after(new);

  // Make so that we can not merge out of the arena in the end
  sentinel->bfree = TRUE;
  sentinel->bsize = new->size;
  sentinel->free = FALSE;
  sentinel->size = 0;

  arena = (struct head*)new;

  return new;
}
		   
  
		      
