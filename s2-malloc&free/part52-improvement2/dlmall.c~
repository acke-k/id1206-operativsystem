#include <stdint.h>
#include <stdio.h>
#include <sys/mman.h>
#include <errno.h>
#include <sys/types.h>

#include <unistd.h>

/* Maybe change the size of these variables in the future to reduce overhead or
   increase performance */
struct head {
  uint16_t bfree; // Is the block before free?
  uint16_t bsize; // The size of the block before
  uint16_t free;  // Is this block free?
  uint16_t size;  // The size of this block
  struct head *prev;  // The previous block in the list
  struct head *next;  // The next block in the list
  struct arena* home; // The arena this block belongs to
};

struct arena {
  struct head* arena;
  struct head* flist;
  struct arena* next;
};

#define TRUE 1
#define FALSE 0

#define HEAD (sizeof(struct head)) // For now, 24 bytes
#define MIN(size) (((size) > (8))?(size):(8)) // Smallest size that a block can be, 8 bytes for now
#define LIMIT(size) (MIN(0) + HEAD + size)  // A block cannot be split if it is smaller than this
#define MAGIC(memory) ((struct head*)memory - 1)  // Retrive the head of a block
#define HIDE(block) (void*)((struct head*)block + 1) // Hide the head of a block

#define ALIGN 8 // Since we are using a 64 bit processor
#define ARENA (64*1024)  // The block we start out with, i.e. the size of the heap

int flist_length;
struct arena* arena_head; // This is the head of out list of arenas

/* BLOCK LOGIC */

// Takes in a pointer to a block and returns a pointer to the next/previous block
struct head *after(struct head *block) {
  return (struct head*)((char*)block + (block->size) + HEAD);
}
struct head *before(struct head *block) {
    return (struct head*)((char*)block - (block->bsize) - HEAD);
}
   

struct head *split(struct head *block, int size) {
  int rsize = block->size - HEAD - size;  // calculate how much space will remain in the given block
  block->size = rsize;

  struct head *splt = HIDE(block) + rsize; // Find where the new block will begin
  splt->bsize = rsize;
  splt->bfree = block->free;
  splt->size = size;
  splt->free = TRUE;  // Should this be initialized as true or false after splitting?

  struct head *aft = after(splt);
  aft->bsize = size;

  return splt;

  // NOTE: why aren't we typing block->next = splt ?
  // We'll do it later, just return the split block for now
}

// Creating the initial memory which we can use

// This function now returns a new arena struct
struct arena* new() {

  struct head *new = mmap(NULL, ARENA, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if(new == MAP_FAILED) {
    printf("mmap failed: error %d\n", errno);
    return NULL;
  }

  uint size = ARENA - (2*HEAD); 
  // Make it so that we can not merge out of the arena through the beginning
  new->bfree = FALSE;
  new->bsize = 0;
  new->free = TRUE;
  new->size = size;
  
  struct head *sentinel = after(new);

  // Make it so that we cannot merge out of the arena through the end
  sentinel->bfree = TRUE;
  sentinel->bsize = new->size;
  sentinel->free = FALSE;
  sentinel->size = 0;

  flist_length = 1;

  struct arena* new_arena;
  // Both pointers are initiated to the same address, similar to the old program
  
  new_arena->arena = (struct head*) new;
  new_arena->flist = (struct head*) new;
  new_arena->flist->home = new_arena;
  
  return new_arena;
}


// Detach a block, i.e. remove it(?) Should it be returned somewhere?
void detach(struct head *block) {
  struct arena* home  = block->home;
  // If the block is not the last element in the list
  if(block->next != NULL) {
    (block->next)->prev= block->prev;
  }
  // If the block isn't the first element in the list
  if (block->prev != NULL) {
    (block->prev)->next = block->next;
  }
  // If the block is the first element in the list
  else {
    home->flist = (home->flist->next);
  }
  flist_length--;
  return;
}

// Insert a new block into the front of the list
void insert(struct head *block) {
  struct arena* home = block->home;
  flist_length++;
  block->next = home->flist;
  block->prev = NULL;
  if (home->flist != NULL) {  // If the list isn't empty
    home->flist->prev = block;
  }
  home->flist = block;
}

/* Malloc & free implementation  */

// Take an integer and return the closest multiple of ALIGN, rounded upwards
int adjust(size_t request) {
  int minsize = MIN(request);
  if(minsize % ALIGN == 0) {
    return minsize; 
  } else {
    int adj = minsize % ALIGN;
    return minsize + ALIGN - adj;
  }
}
// Find an appropiate block in freelist using the take first algorithm
struct head* find(size_t size) {
  sleep(1);
  // If arena_head is empty, i.e. we haven't initiated an arena yet, do that
  if(arena_head == NULL) {
    arena_head = new();
    arena_head->next = NULL;
  }
 
  
  struct head* index = arena_head->flist; // Ändra detta så att vi kan söka genom flera arenor om det ej finns utrymme i arena_head
  // Take first algorithm
  while(index != NULL) { // Iterate through flist
    // Can we split the current block? If yes, choose this block
    if(index->size >= size) {
      struct head* new_block;
      // Detach the block, split it, and insert the leftover
      detach(index);

      if(index->size > LIMIT(size)) {
	new_block = split(index, size);
	insert(index);
      } else {
	new_block = index; 
      }
      // Make sure that the header of the new block is correct
      new_block->free = FALSE;
      after(new_block)->bfree = FALSE;
      new_block->home = arena_head; // Ändra detta så att vi väljer rätt arena, när vi kollar genom flera
      return new_block;
    }
    index = index->next;
  }
  // If we cannot find a large enough block
  return NULL; // Kanske itera arena här??
}

struct head* merge(struct head* block) {

  struct head* aft = after(block);
  // If the block before is free
  if(block->bfree) {
    
    struct head* bef = before(block);
    
    // Unlink the block before  
    detach(bef);

    // Calculate and set the total size of the soon to be merged blocks
    bef->size = HEAD + block->size + bef->size;
    
    // update the block after the merged blocks
    aft->bsize = bef->size;
    after(block)->bsize = bef->size;
    
    // Continue with the merged block
    block = bef;
  }
  // If the block after is free
  if(aft->free) {
    // Unlink the block
    detach(aft);
    // Calculate the total size of the merged blocks
    int size = HEAD + block->size + aft->size;
    // Update the block after the merged block
    after(block)->bfree = TRUE;
    after(block)->bsize = size;
    block->size = size;
  }
  return block;
}
// My own version of malloc
void *dalloc(size_t request) {
  if(request <= 0) {
    return NULL;
  }
  int size = adjust(request);
  struct head *taken = find(size);
  if (taken == NULL) {
    return NULL;
  } else {
    return HIDE(taken);
  }
}
// My own version of free
void dfree(void *memory) {
  if(memory != NULL) {
    // Find the start of the header
    struct head *block = MAGIC(memory);
    // Try to merge block with another one
    block = merge(block);
    
    struct head *aft = after(block);
    block->free = TRUE;
    aft->bfree = TRUE;
    aft->bsize = block->size;
    insert(block);
  }
  return;
}
// Prints flist & all blocks
void sanity_print() {
  /* print all blocks */

  // first, iterate all arenas
  struct arena* current_arena = arena_head;
  while(current_arena != NULL) {
    struct head* index = (struct head*)current_arena;
    int i = 0;
    printf("ALL BLOCKS\n");
    while(!(index->free == FALSE && index->size == 0)) {
      printf("%3d:  size: %10d   address: %20p  free: %d\n", i, index->size, index, index->free);
      index = after(index);
      i++;
    }
    current_arena = current_arena->next;
  }

  current_arena = arena_head;
  while(current_arena != NULL) {
    /* print freelist */
    struct head* index = current_arena->flist;
    int i = 0;
    printf("FREELIST\n");
    while(index != NULL) {
      printf("%3d: size: %10d   address: %16p  next: %16p\n", i, index->size, index, index->next);
      index = index->next;
      i++;
    }
    current_arena = current_arena->next;
  }
}
void sanity(int arg) {
  printf("Sanitycheck\n");
  /* Go through all arenas */
  struct arena* current_arena = arena_head;
  while(current_arena != NULL) {
    /* Iterate through the freelist */
    printf("flist: %p\n", current_arena->flist);
    struct head* index = current_arena->flist;
    struct head* prev = current_arena->flist->prev;;
    while(index != NULL) {
      if(prev != index->prev) {
	printf("Error: Prev isnt prev!\n");
      }
      if(index->free == FALSE) {
	printf("Error: Isnt marked as free!\n");
      }
      if(index->size % 8 != 0) {
	printf("Error: Size isnt alligned!!\n");
      }
      prev = index;
    index = index->next;
    }
    /* Iterate blocks */
    index = (struct head*)current_arena;
    while(!(after(index)->free == FALSE && after(index)->size == 0)) {
      index = after(index);
    }
    current_arena = current_arena->next;
  }
  if(arg == 1) {
    sanity_print();
  }
}

int flist_size() {
  return flist_length;
}
// Average blocksize. Iterate all blocks so that we easily can ignore the large block at the first position
float flist_blocksize() {
  
  float avrg = 0.0;
  struct head* index = (struct head*)arena_head->next;
  
  while(index != NULL) {
    if(index->free) {
      avrg += index->size;
    }
    index = index->next;
  }
  return avrg / flist_size();
}
  
  

  
   
    
    


